# 这里的问题只是为了描述递归思想，帮助自己复习，以及初学者可以更好体会递归。给出的代码不考虑任何其他诸如效率问题。

## 把数字转为字符串打印出来

   通常，计算机只是把一个数字对应的字符串的表示打印出来，任意的数只能用字符串表示出来，就和我们亲手写下数字一样，它只是一种符号，并且，对于这个问题来说完全没有意义。我们直接输入一个数字，它在底层自动会被计算机转换成字符串显示出来。这里，我想要说明的是一个有问题的递归方式(小于等于0无效)，这是重点。

   对于这问题，刚开始是无从下手。然而基本的想法很平常，对于n=12345的数来说，我们可以先打印出1234,然后把5对应的字符打印出来;随后，打印1234时，先打印123,再把4对应的字符串打印出来。依次进行，如果剩下一个字符，我们可以直接把这个树对应的字符串输出，就完成了打印12345的任务了。

想法很简单，结论却让人大开眼界，下面给出java代码。

   ```java
        char[] N= {'0','1','2','3','4','5','6','7','8','9'};
        final int UNIT=10;
        void NumberToString(int n) {
            if(n>0) {
                NumberToString(n/UNIT);
                System.out.print(N[n%UNIT]);
            }
        }
   
   ```

## 打印汉诺塔问题步骤



  ```java
    
	void HanNuoTa(char a,char b,char c,int n) {
		if(n>0) {
			HanNuoTa(a, c, b, n-1);
			System.out.println(a+"-->"+b);
			HanNuoTa(c, b, a, n-1);
		}
	}
  
  ```

## 打印出给定序列的所有排列

  ```java
        private <T> void swap(T[] sq, int i, int j) {
            T k = sq[i];
            sq[i] = sq[j];
            sq[j] = k;
        }

        Character[] PN = { '1', '2', '3', '4' };

        public void PaiLie(Character[] sq, int left, int right) {
            if (left == right)
                System.out.println(Arrays.toString(sq));
            else {
                for (int i = left; i <= right; i++) {
                    swap(sq, left, i);
                    PaiLie(sq, left + 1, right);
                    swap(sq, left, i);
                }
            }
        }
  ```

## 爬楼梯
  ```java
        public int PaLouTi(int n) {
            if(n==1)
                return 1;
            else if(n==2)
                return 1;
            else
                return PaLouTi(n-1)+PaLouTi(n-2);
        }
  ```

## 切割刚条

这是算法导论中用来介绍动态规划的第一个列子，那是另外一个话题，这里我们只说明递归想法。

大意是，公司希望把长钢条切割成短钢条出售，以谋求最大收益。不考虑切割成本，切割的每段钢条的长度为整数，下面是不同长度对应的价格。

| 长度i  | 1    | 2    | 3    |  4   |  5   | 6    | 7    | 8    | 9    | 10   |
| ------ | ---- | ---- | ---- | :--: | :--: | ---- | ---- | :--- | ---- | ---- |
| 价格Pi | 1    | 5    | 8    |  9   |  10  | 17   | 17   | 20   | 24   | 30   |

也就是说，对于长度L=10的钢条，如何切割才能获取最大收益？切为几段，每段是多少长度。这里我们只考虑最大收益。

长度为10的钢条每一段都会切割或者不切割，切割方式是一共2的指数次幂。收益是这样计算的：如果L=4的钢条切为1，1，2三段，则总收益是

s=1+1+5

想象这样的场景:

1. L长度的钢条，第一种情况不切割，返回是它本身的价格的收益。由于不能保证这样的方式是收益最大方式，所以返回去进行第二种情况。
2. 第二种情况从左面切下i=1，长度为L的钢条变为1和L-1的两个规模更小的本质相同类型子问题。对左面长度无法切割，对右面L-1作同样的切割方式，然后返回总收益。
3. 第三种从左面切下i=2，现在变为2和L-2的两个又是更小规模的子问题：对左面2进行同样操作，然后对右面L-2操作，再次返回总收益。
4. 以此类推，i=3,4,5....L进行L次重复，然后L次收益比较出最大的结果返回，相同的最大收益情况任意返回一个，最终返回长度为L的钢条的最大收益。

想象一下另外一种场景，我们把长度L的钢条切割完成后可能是这样组成的，我们这样看待他：

1. 第一种，可能左面剩下长度为1的钢条没有切割，对右面L-1进行切割。
2. 第二种，可能左面剩下长度为2没切割,右面L-2进行切割。
3. 第三种，可能左面剩下长度为3没切割，右面L-3切割。
4. 依次类推，比较得出最大收益，这个收益是可能的最大收益方式中的一个，把它返回。

这是第二种想法的实现:

```java
	public static int[] P = { 1, 5, 8, 9, 10, 17, 17, 20, 24, 30 };

	public int Cut(int L) {
		if (L == 0)
			return 0;
		int max = 0;
		int temp = 0;
        //L种情况
		for (int i = 1; i < =L; i++) {
			temp = Cut(L - i) + P[i - 1];
			max = max > temp ? max : temp;
		}
		return max;
	}
```



## 最长公共子字符串
 ```java
        final char[] s1 = { '6', '2', '3', '4' };
        final char[] s2 = { '1', '2', '3', '4' };

        public String LCS(char[] s1, int ls1, char[] s2, int ls2) {
            if (ls1 < 0 || ls2 < 0)
                return "";
            if (s1[ls1] == s2[ls2])
                return LCS(s1, ls1 - 1, s2, ls2 - 1) + s1[ls1];
            else {
                String a1 = LCS(s1, ls1, s2, ls2 - 1);
                String a2 = LCS(s1, ls1 - 1, s2, ls2);
                return a1.length() > a2.length() ? a1 : a2;
            }
        }
 ```

